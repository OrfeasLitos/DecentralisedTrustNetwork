\documentclass[11pt]{llncs}
\usepackage{preamble}

\begin{document}
  Let $A \in \mathcal{V}$ source, $B \in \mathcal{V}$ sink. For the following, we suppose that $Turn_{j-1}$ has just finished
  and $A = Player\left(j\right)$ is currently deciding $Turn_j$. We use the following notation:
  \begin{align*}
     c_{Av} &= DTr_{A \rightarrow v, j-1} \\
     c'_{Av} &= DTr_{A \rightarrow v, j}
  \end{align*}
  Moreover, $X$ and $X'$ will be the flows returned by some execution of
  $MaxFlow_{\mathcal{G}_{j-1}}\left(A, B\right)$ and $MaxFlow_{\mathcal{G}_j}\left(A, B\right)$ respectively.

  Furthermore, we suppose an arbitrary ordering of the members of $N^{+}\left(A\right)$. We set $n = |N^{+}\left(A\right)|$.
  Thus
  \begin{equation*}
     N^{+}\left(A\right) = \{v_1, ..., v_n\}
  \end{equation*}
  We use these subscripts to refer to the respective capacities (a.k.a. direct trusts) and flows. Thus
  \begin{equation*}
     \begin{array}{l}
        x_i = x_{Av_i} \enspace, \\
        c_i = c_{Av_i} \enspace,
     \end{array}
     \mbox{ where } i \in [n]
  \end{equation*}

  \import{thesis/definitions/}{trustreduction.tex}
  \import{thesis/definitions/}{restrictedflow.tex}

  \import{thesis/theorems/}{saturationtheorem.tex}
  \import{thesis/proofs/}{saturationproof.tex}

  \import{thesis/theorems/}{trusttransfertheorem.tex}
  \import{thesis/proofs/}{trusttransferproof.tex}

  \import{thesis/lemmas/}{flowlimitlemma.tex}
  \import{thesis/proofs/}{flowlimitproof.tex}

  \import{thesis/theorems/}{trustsavingtheorem.tex}
  \import{thesis/proofs/}{trustsavingproof.tex}

  \import{thesis/theorems/}{invtrustrednaivetheorem.tex}
  \import{thesis/proofs/}{invtrustrednaiveproof.tex}

  Until now $MaxFlow$ has been viewed purely as an algorithm. This algorithm is not guaranteed to always return the same
  flow when executed muliple times on the same graph. However, the corresponding flow value, $maxFlow$, is always the same.
  Thus $maxFlow$ can be also viewed as a function from a matrix of capacities to a positive real number. Under this
  perspective, we prove the following theorem. Let $\mathcal{C}$ be the family of all capacity matrices
  $C = [c_{vw}]_{V\left(\mathcal{G}\right) \times V\left(\mathcal{G}\right)}$.
  \import{thesis/theorems/}{maxflowcontinuitytheorem.tex}
  \import{thesis/proofs/}{maxflowcontinuityproof.tex}

  Here we show three naive algorithms for calculating new direct trusts so as to maintain invariable risk when paying
  a trusted party. Let $F = \sum\limits_{i=1}^{n}x_i$. To prove the correctness of the algorithms, it suffices to prove that
  \begin{equation}
  \label{naive:req1}
     \forall i \in [n], c'_i \leq x_i \mbox{ and}
  \end{equation}
  \begin{equation}
  \label{naive:req2}
     \sum\limits_{i=1}^{n}c'_i = F - V \enspace.
  \end{equation}
  \import{thesis/algorithms/}{fcfscode.tex}
  \import{thesis/proofs/}{fcfscorrectness.tex}
  \import{thesis/proofs/}{fcfscomplexity.tex}

  \import{thesis/algorithms/}{abscode.tex}
  \noindent
  We will start by showing some results useful for the following proofs. Let $j$ be the number of iterations of the
  \textbf{while} loop for the rest of the proofs for algorithm \ref{abs} (think of $i$ from line~\ref{absiincrement}
  without the $mod\:n$).\\
  First we will show that $empty \leq n$. $empty$ is only modified on line~\ref{absemptyincrement} where it is
  incremented by 1. This happens only when $u_i' > 0$ (line~\ref{absifcappositive}), which is assigned the value 0 on
  line~\ref{abscapzero}. We can see that the incrementation of $empty$ can happen at most $n$ times because
  $|U'| = n$. Since $empty_0 = 0$, $empty \leq n$ at all times of the execution. \\
  Next we will derive the recursive formulas for the various variables. \\
  $empty_0 = 0$ \\
  $empty_{j+1} = 
     \begin{cases}
        empty_j, & u_{(j+1)\:mod\:n}' = 0 \\
        empty_j+1, & u_{(j+1)\:mod\:n}' > 0 \: \wedge \: x_{(j+1) \:mod\:n} < reduce_j \\
        empty_j, & u_{(j+1)\:mod\:n}' > 0 \: \wedge \: x_{(j+1) \:mod\:n} \geq reduce_j
     \end{cases}$ \\ \ \\
  $reduce_0 = \frac{V}{n}$ \\
  $reduce_{j+1} =
     \begin{cases}
        reduce_j, & u_{(j+1)\:mod\:n}' = 0 \\
        reduce_j + \frac{reduce_j-x_{(j+1)\:mod\:n}}{n-empty_{j+1}}, & u_{(j+1)\:mod\:n}' > 0 \: \wedge \:
           x_{(j+1) \:mod\:n} < reduce_j \\
        reduce_j, & u_{(j+1)\:mod\:n}' > 0 \: \wedge \: x_{(j+1) \:mod\:n} \geq reduce_j
     \end{cases}$ \\ \ \\
  $reduction_0 = 0$ \\
  $reduction_{j+1} =
     \begin{cases}
        reduction_j, & u_{(j+1)\:mod\:n}' = 0 \\
        reduction_j + u_{(j+1)\:mod\:n}', & u_{(j+1)\:mod\:n}' > 0 \: \wedge \: x_{(j+1) \:mod\:n} < reduce_j \\
        reduction_j + u_{(j+1)\:mod\:n}' - x_{(j+1)\:mod\:n} + reduce_{j+1}, &
           u_{(j+1)\:mod\:n}' > 0 \: \wedge \: x_{(j+1) \:mod\:n} \geq reduce_j
     \end{cases}$ \\
  In the end, $r = reduce$ is such that $r = \frac{V - \sum\limits_{x \in S}x}{n - |S|}$ where
  $S = \{\text{flows } y \text{ from } s \text{ to } N^{+}(s) \text{ according to } maxFlow : y < r\}$. Also,
  $\sum\limits_{i=1}^{n}u_i' = \sum\limits_{i=1}^{n}\max{(0,x_i - r)}$. TOPROVE
  \import{thesis/proofs/}{abscorrectness.tex}
  \import{thesis/proofs/}{abscomplexity.tex}

  A variation of this algorithm using a Fibonacci heap with complexity $O(n)$ can be created, but that is part of
  further research.
  \import{thesis/proofs/}{absDinfnormminproof.tex}

  \import{thesis/algorithms/}{propcode.tex}
  \import{thesis/proofs/}{propcorrectness.tex}
  \import{thesis/proofs/}{propcomplexity.tex}

  Naive algorithms result in $u_i' \leq x_i$, thus according to \ref{invariability}, $||\delta_i||_1$ is invariable for
  any of the possible solutions $U'$, which is not necessarily the minimum (usually it will be the maximum). The following
  algorithms concentrate on minimizing two $\delta_i$ norms, $||\delta_i||_\infty$ and $||\delta_i||_1$. \\
  \import{thesis/algorithms/}{dinfmincode.tex}
  Since trust should be considered as a continuous unit and binary search dissects the possible interval for the solution
  on each recursive call, inclusion of the $\epsilon$-parameters in \texttt{BinSearch} is necessary for the algorithm to
  complete in a finite number of steps. \\
  \import{thesis/algorithms/}{dinfbinsearchcode.tex}
  \import{thesis/proofs/}{maxflowdecproof.tex}
  We can see that if $V > 0, F' = F - V < F$ thus if $\delta \in (0, \max\limits_{i \in [n]}\{u_i\}]:
  maxFlow(\delta)= F' \Rightarrow \delta = \min||\delta_i||_\infty : maxFlow(||\delta_i||_\infty) = F'$.

  \import{thesis/proofs/}{dinfbinsearchcorrectness.tex}
  \import{thesis/proofs/}{dinfbinsearchcomplexity.tex}
  \import{thesis/proofs/}{dinfmincorrectness.tex}
  \import{thesis/proofs/}{dinfmincomplexity.tex}

  However, we need to minimize $\sum\limits_{i=1}^{n}(u_i-u_i') = ||\delta_i||_1$.

\end{document}
