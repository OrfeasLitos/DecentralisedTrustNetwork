\documentclass[11pt]{article}
\usepackage[a4paper,top=2cm,bottom=2cm,left=1.5cm,right=1.5cm]{geometry}
\usepackage{graphicx}
\usepackage[linesnumbered,ruled,noend]{algorithm2e}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{amsthm}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{amssymb}
\usepackage{fancyvrb}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{hyperref}
\usepackage{courier}
\usepackage{listings}

\newtheorem{theorem}{Theorem}[section]
\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\theoremstyle{corollary}
\newtheorem{corollary}{Corollary}[section]
\theoremstyle{lemma}
\newtheorem{lemma}{Lemma}[section]

\lstset{frame=tb,
%  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

% PDF bookmarks
\usepackage{color,hyperref}
\definecolor{darkblue}{rgb}{0.0,0.0,0.3}
\hypersetup{colorlinks,breaklinks,
    linkcolor=darkblue,urlcolor=darkblue,
    anchorcolor=darkblue,citecolor=darkblue}

\pagestyle{fancy}{ %
    \fancyhf{} % remove everything
        \renewcommand{\headrulewidth}{0pt} % remove lines as well
        \renewcommand{\footrulewidth}{0.5pt}
        \rhead{\leftmark}
        \lhead{Decentralized financial reputation with multisig for lines-of-credit}
        \rfoot{Page \thepage\ of \pageref{LastPage}}}
        
\begin{document}
  \begin{centering}
     \Large{\textbf{Trust Is Risk: Introducing a decentralized platform for financial trust}}
  \end{centering}
  \ \\ \ \\
  \hspace*{\fill}
  \begin{minipage}[t]{7cm}
     \begin{flushleft}
        Orfeas Stefanos Thyfronitis Litos \\
        \textit{National Technical University of Athens}
     \end{flushleft}
  \end{minipage}
  \hfill
  \begin{minipage}[t]{7cm}
     \begin{flushright}
        Dionysis Zindros \\
        \textit{University of Athens}
     \end{flushright}
  \end{minipage}
  \hspace*{\fill}

  \section{Abstract}
  Reputation in centralized systems typically uses stars and review-based
  trust. These systems require extensive manual intervention and secrecy to
  avoid manipulation. In decentralized systems this luxury is not available
  as the reputation system should be autonomous and open source. Previous
  peer-to-peer reputation systems define trust abstractly and do not allow for
  financial arguments pertaining to reputation. We propose a concrete
  sybil-resilient decentralized reputation system in which direct trust is
  defined as lines-of-credit using bitcoin's 1-of-2 multisig. We introduce a new
  model for bitcoin wallets in which user coins are split among trusted friends.
  Indirect trust is subsequently defined using a transitive property. This
  enables formal game theoretic arguments pertaining to risk analysis. Using our
  reputation model, we prove that risk and max flows are equivalent and propose
  several algorithms for the redistribution of trust so that a decision can be
  made on whether an anonymous third party can be indirectly trusted. In such a
  setting, the risk incurred by making a purchase from an anonymous vendor
  remains invariant. Finally, we prove the correctness of our algorithms and
  provide optimality arguments for various norms.

  \section{Introduction}

  \section{Tags/Keywords}
      decentralized, trust, web-of-trust, bitcoin, multisig, line-of-credit, trust-as-risk, flow  

  \section{Related Work}

  \section{Key points}

  \section{Definitions}
      \begin{definition}[Players] \ \\
         The set $\mathcal{M} = V(G)$ is the set of all players in the network, otherwise understood as the set of all
         pseudonymous identities.
      \end{definition}
      \begin{definition}[Capital of $A$, $Cap_A$] \ \\
        Total amount of value that exists in P2PKH in the UTXO and can be spent by $A$. We also define $Cap_{A,j}$ as
        the total amount of value that exists in P2PKH in the UTXO and can be spent by $A$ in turn $j$.
      \end{definition}
      \begin{definition}[Direct Trust from $A$ to $B$, $DTr_{A \rightarrow B}$] \ \\
         Total amount of value that exists in 1/$\{A,B\}$ multisigs in the UTXO, where the money is deposited by $A$.
      \end{definition}
      \begin{definition}[(In/Out) Neighbourhood of $A$, $N^{+}(A), N^{-}(A), N(A)$] \ 
         \begin{enumerate}
            \item Let $N^{+}(A)$ be the set of players $B$ that $A$ directly trusts with any positive value. More
               formally, $N^{+}(A) = \{B \in \mathcal{M} : DTr_{A \rightarrow B} > 0\}$. $N^{+}(A)$ is called out
               neighbourhood of $A$.
            \item Let $N^{-}(A)$ be the set of players $B$ that directly trust $A$ with any positive value. More
               formally, $N^{-}(A) = \{B \in \mathcal{M} : DTr_{B \rightarrow A} > 0\}$. $N^{-}(A)$ is called in
               neighbourhood of $A$.
            \item Let $N(A)$ be the set of players $B$ that either directly trust or are directly trusted by $A$ with
               any positive value. More formally, $N(A) = N^{+}(A) \cup N^{-}(A)$. $N(A)$ is called
               neighbourhood of $A$.
            \item Let $N(A)_i$ (respectively $N^{+}(A)_i, N^{-}(A)_i$) be the $i$-th element of set $N(A)$
               (respectively of $N^{+}(A), N^{-}(A)$), according to an arbitrary but constant enumeration of
               the set players.
         \end{enumerate}
      \end{definition}
%      \begin{definition}[$B$ steals $x$ from $A$] \ \\
%         $B$ steals value $x$ from $A$ when $B$ reduces the $DTr_{A \rightarrow B}$ by $x$ and increases $Cap_B$ by $x$.
%         This makes sense when $x \leq DTr_{A \rightarrow B}$.
%      \end{definition}
      \begin{definition}[Turns] \ \\
         The game we are describing is turn-based. Let $DTr_{B \rightarrow A, j}$ be $B$'s direct trust to $A$ in turn $j$.
         In each turn $j$ exactly one player $A \in \mathcal{M}, A = Player(j)$, chooses an action (according to a certain
         strategy) that can be one of the following, or a finite combination thereof:
         \begin{enumerate}
            \item Do nothing ($\emptyset$).
            \item Steal value $y_B, 0 \leq y_B \leq DTr_{B \rightarrow A, j-1}$ from $B \in N^{-}(A)$.
            $DTr_{B \rightarrow A, j} = DTr_{B \rightarrow A, j-1} - y_B, Cap_{A,j} = Cap_{A,j-1} + y_B$.
            ($Steal(y_B, B)$)
            \item Add value $y_B, -DTr_{A \rightarrow B, j-1} \leq y_B$ to $B \in \mathcal{M}$.
            $DTr_{A \rightarrow B, j} = DTr_{A \rightarrow B, j-1} + y_B, Cap_{A,j} = Cap_{A,j-1} - y_B $. When
            $y_B < 0$, we say that $A$ reduces her trust to $B$ by $-y_B$, when $y_B > 0$, we say that $A$ increases her
            trust to $B$ by $y_B$. If $DTr_{A \rightarrow B, j-1} = 0$, then we say that $A$ starts directly trusting $B$.
            ($Add(y_B, B)$)
         \end{enumerate}
         If player $A$ chooses to pass her turn, she may not choose any additional action in the same turn.
         Also, let $Y_{st}, Y_{add}$ be the total value to be stolen and added respectively by $A$ in her turn, $j$. For a
         turn to be feasible, it must hold that $Y_{add} - Y_{st} \leq Cap_{A,j-1}$. Moreover, player $A$ is not allowed to
         choose two actions of the same kind against the same player in the same turn. \\
         The set of actions a player makes in turn $j$ is $Turn_j$. Examples:
         \begin{itemize}
            \item $Turn_{j_1} = \emptyset$
            \item $Turn_{j_2} = \{Steal(y, B), Add(w, B)\}$ (given that $DTr_{B \rightarrow A, j_2 - 1} \leq y \wedge
            -DTr_{A \rightarrow B, j_2 - 1} \leq w \wedge y - w \leq Cap_{A, j_2-1}$, where $A = Player(j_2)$)
            \item $Turn_{j_3} = \{Steal(x, B), Add(y, C), Add(w, D)\}$ (given that $DTr_{B \rightarrow A, j_3 - 1} \leq x
            \wedge -DTr_{A \rightarrow C, j_3-1} \leq y \wedge -DTr_{A \rightarrow D, j_3 - 1} \leq w \wedge
            x - y - w \leq Cap_{A, j_3-1}$, where $A = Player(j_3)$)
            \item $Turn_{j_4} = \{Steal(x, B), Steal(y, B)\}$ is not a valid turn because it contains two $Steal()$ actions
            against the same player. If $x + y \leq DTr_{B \rightarrow A}$, the correct alternative would be $Turn_{j_4} =
            \{Steal(x+y, B)\}$, where $A = Player(j_4)$.
         \end{itemize}
      \end{definition}
      \begin{definition}[$A$ is stolen $x$] \ \\
         Let $j, j'$ be two consecutive turns of $A$ ($j, j' : Player(j) = Player(j') = A \wedge j < j' \wedge \nexists j''
         \in \mathbb{N} \cap (j, j') : Player(j'') = A$). We say that $A$ has been stolen a value $x$ between $j$ and $j'$
         if $\sum\limits_{i=1}^{|N^{+}(A)|}DTr_{A \rightarrow N^{+}(A)_i, j} -
         \sum\limits_{i=1}^{|N^{+}(A)|}DTr_{A \rightarrow N^{+}(A)_i, j'} = x > 0$. If turns are not specified,
         we implicitly refer to the current and the previous turns.
      \end{definition}
      \begin{definition}[History] \ \\
         We define History, $\mathcal{H}$, as the sequence of all the tuples containing the sets of actions and the
         corresponding player. $\mathcal{H}_j = (Player(j), Turn_j)$.
      \end{definition}
      \begin{definition}[Conservative strategy] \ \\
         A player $A$ is said to follow the conservative strategy if for any value $x$ that has been stolen from her since
         the previous turn she played, she substitutes it in her turn by stealing from others that trust her value
         equal to $\min{(x,\sum\limits_{B \in \mathcal{M}}{DTr_{B \rightarrow A}})}$ and she takes no other action.
         More formally, let $j' = \max\{k \in \mathbb{N} : k < j \wedge Player(k) = Player(j)\}, Damage = \sum\limits_{i=1}
         ^{|N^{+}(A)|}DTr_{A \rightarrow N^{+}(A)_i, j'} - \sum\limits_{i=1}^{|N^{+}(A)|}DTr_{A \rightarrow N^{+}(A)_i,j-1}$.
         If $Strategy(A) = Conservative$, then $\forall j \in \mathbb{N}: Player(j) = A$ it is $$Turn_j =
         \begin{cases}
            \emptyset, & Damage \leq 0 \\
            \{Steal(y_1,N^{-}(A)_1),...,Steal(y_{|N^{-}(A)|},N^{-}(A)_{|N^{-}(A)|})\}, & Damage > 0
         \end{cases}$$
         In the second case, it is $\sum\limits_{i=1}^{|N^{-}(A)|}y_i = \min(\sum\limits_{i=1}^{|N^{-}(A)|}DTr_{A \rightarrow
         N^{-}(A)_i, j-1}, Damage)$. \\
         As we can see, the definition covers a multitude of options for the conservative player, since in case $0 < Damage <
         \sum\limits_{i=1}^{|N^{-}(A)|}DTr_{A \rightarrow N^{-}(A)_i, j-1}$ she can choose to distribute the $Steal(s)()$
         in any way she chooses, as far as $\forall i, y_i \leq DTr_{N^{-}(A)_i \rightarrow A, j-1} \wedge \sum\limits_{i=1}^
         {|N^{-}(A)|}y_i = Damage$.
      \end{definition}
      \begin{definition}[Idle strategy] \ \\
         A player $A$ is said to follow the idle strategy if she passes in her turn. More formally, if $Strategy(A) =
         Idle$, then $\forall j \in \mathbb{N} : Player(j) = A$ it is $Turn_j = \emptyset$.
      \end{definition}
      \begin{definition}[Evil strategy] \ \\
         A player $A$ is said to follow the evil strategy if she steals value $y_B = DTr_{B \rightarrow A, i-1} \:
         \forall \: B \in N^{-}(A)$ (steals all incoming direct trust) and reduces her trust to $C$ by
         $DTr_{A \rightarrow C, i-1} \: \forall \: C \in N^{+}(A)$ (nullifies her outgoing direct trust) in her turn.
         More formally, if $Strategy(A) = Evil$, then $\forall j \in \mathbb{N} : Player(j) = A$ it is $Turn_j =
         \{Steal(y_1,N^{-}(A)_1),...,Steal(y_m,N^{-}(A)_m), Add(w_1,N^{+}(A)_1),...,Add(w_l,N^{+}(A)_l)\}$ where
         $m = |N^{-}(A)|, l = |N^{+}(A)|, \forall i \in [m] y_i = DTr_{N^{-}(A)_i \rightarrow A,j-1}, \forall i \in [l]
         w_i = -DTr_{A \rightarrow N^{+}(A)_i,j-1}$.
      \end{definition}
      \begin{definition}[Indirect trust from $A$ to $B$, $Tr_{A \rightarrow B}$] \ \\
         Maximum possible value that can be stolen from $A$ if $B$ follows the evil strategy, $A$ follows the idle strategy
         and everyone else ($\mathcal{M} \setminus \{A,B\}$) follows the conservative strategy. More formally,
         $$Tr_{A \rightarrow B, j} = \max\limits_{j' : j' > j, configurations}{[\sum\limits_{i=1}^{|N^{+}(A)|}DTr_{A 
         \rightarrow N^{+}(A)_i,j}-\sum\limits_{i=1}^{|N^{+}(A)|}DTr_{A \rightarrow N^{+}(A)_i,j'}]}$$ where
         $Strategy(A) = Idle, Strategy(B) = Evil, \forall C \in \mathcal{M} \setminus \{A,B\} Strategy(C) = Conservative$.
      \end{definition}
      \begin{definition}[Indirect trust from $A$ to $S \subset \mathcal{M}$, $Tr_{A \rightarrow S}$] \ \\
         Maximum possible value that can be stolen from $A$ if all players in $S$ follow the evil strategy, $A$ follows
         the idle strategy and everyone else ($\mathcal{M} \setminus (S \cup \{A\}$) follows the conservative strategy. More
         formally, $$Tr_{A \rightarrow S, j} = \max\limits_{j' : j' > j, configurations}{[\sum\limits_{i=1}^{|N^{+}(A)|}
         DTr_{A \rightarrow N^{+}(A)_i,j}-\sum\limits_{i=1}^{|N^{+}(A)|}DTr_{A \rightarrow N^{+}(A)_i,j'}]}$$ where
         $Strategy(A) = Idle, \forall E \in S, Strategy(E) = Evil,
         \forall C \in \mathcal{M} \setminus \{A,E\} Strategy(C) = Conservative$.
      \end{definition}
      \begin{definition}[Trust Reduction] \ \\
         Let $A, B \in \mathcal{M}, x_i$ flow to $N^{+}(A)_i$ resulting from $maxFlow(A,B), u_i =
         DTr_{A \rightarrow N^{+}(A)_i,j-1}, u_i' = DTr_{A \rightarrow N^{+}(A)_i,j},$ \\ $i \in [|N^{+}(A)|],
         j \in \mathbb{N}$.
         \begin{enumerate}
            \item The Trust Reduction on neighbour $i, \delta_i$ is defined as $\delta_i = u_i - u_i'$.
            \item The Flow Reduction on neigbour $i, \Delta_i$ is defined as $\Delta_i = x_i - u_i'$.
         \end{enumerate}
         We will also use the standard notation for 1-norm and $\infty$-norm, that is:
         \begin{enumerate}
            \item $||\delta_i||_1 = \sum\limits_{i \in N^{+}(A)}\delta_i$
            \item $||\delta_i||_\infty = \max\limits_{i \in N^{+}(A)}\delta_i$.
         \end{enumerate}
      \end{definition}
      \begin{definition}[Restricted Flow] \ \\
         Let $A, B \in \mathcal{M}, i \in [|N^{+}(A)|]$.
         \begin{enumerate}
            \item Let $F_{A_i \rightarrow B}$ be the flow from $A$ to $N^{+}(A)_i$ as calculated by the $maxFlow(A,B)$
               ($x_i'$) when $u_i' = u_i,$ \\ $u_k' = 0 \:\forall k \in [|N^{+}(A)|] \wedge k \neq i$.
            \item Let $S \subset N^{+}(A)$. Let $F_{A_S \rightarrow B}$ be the sum of flows from $A$ to $S$ as
               calculated by the $maxFlow(A,B)$ ($\sum\limits_{i=1}^{|S|}x_i'$) when $u_C' = u_C \: \forall C \in S,
               u_D' = 0 \: \forall D \in N^{+}(A) \setminus S$.
         \end{enumerate}
      \end{definition}
  \section{Theorems-Algorithms}
    \begin{theorem}[Saturation theorem] \ \\ 
    \label{saturation}
       Let $s$ source, $n = |N^{+}(s)|, x_i, i \in [n]$, flows to $s$'s neighbours as calculated by the
       maxFlow algorithm, $u_i'$ new direct trusts to the $n$ neighbours and $x_i'$ new flows to the neighbours
       as calculated by the maxFlow algorithm with the new direct trusts, $u_i'$. It holds that
       $\forall i \in [n], u_i' \leq x_i \Rightarrow x_i' = u_i'$.
    \end{theorem}
    \begin{proof} \ 
       $\forall i \in [n], x_i' > u_i'$ is impossible because a flow cannot be higher than its
       corresponding capacity. Thus $\forall i \in [n], x_i' \leq u_i'$. (1) \\
       In the initial configuration of $u_i$ and according to the flow problem setting, a combination of flows
       $y_i$ such that $\forall i \in [n], y_i = u_i'$ is a valid, albeit not necessarily maximum,
       configuration with a flow $\sum\limits_{i=1}^{n}y_i$. Suppose that $\exists k \in [n] : x_k'
       < u_k'$ as calculated by the maxFlow algorithm with the new direct trusts, $u_i'$. Then for the new
       maxFlow $F'$ it holds that $F' = \sum\limits_{i=1}^{n}x_i' < \sum\limits_{i=1}^{n}y_i$ since $x_k' < y_k$
       and (1) which is impossible because the configuration $\forall i \in [n], x_i' = y_i$ is valid since 
       $\forall i \in [n], y_i = u_i'$ and also has a higher flow, thus the maxFlow algorithm will
       prefer the configuration with the higher flow. Thus we deduce that $\forall i \in [n], x_i' = u_i'$.
    \end{proof}

    \begin{theorem}[Trust convergence theorem] \ \\
    \label{convergence}
       Let $A,B \in \mathcal{M} : Strategy(A) = Idle, Strategy(B) = Evil, \forall C \in \mathcal{M} \setminus \{A,B\},
       Strategy(C) = Conservative$ and $j_0 \in \mathbb{N} : Player(j_0) = B$. Given that all players eventually play, there exists
       a turn $j' > j_0 : \forall j \geq j', Turn_j = \emptyset$.
    \end{theorem}
    \begin{proof}
       First of all, $\forall j > j_0 : Player(j) = B, Turn_j = \emptyset$ because $B$ has already nullified his incoming
       and outgoing direct trusts in $Turn_{j_0}$ and the evil strategy does not contain any case where direct trust is
       increased or where the evil player starts directly trusting another player, thus player $B$ can do nothing. Also
       $\forall j > j_0 : Player(j) = A, Turn_j = \emptyset$ because of the idle strategy that $A$ follows. As far as the
       rest of the players are concerned, consider the following algorithm, where \texttt{RandomMember(}$Set$\texttt{)}
       returns a randomly chosen member of the input set and \texttt{CalculateFlow(}$v, Loss_v$\texttt{)} returns a
       configuration of $Steal()$ actions from $N^{-}(v)$ that comply with the conservative strategy, that is it returns
       $\{Steal(y_1, N^{-}(v)_1),...,Steal(y_{|N^{-}(v)|}, N^{-}(v)_{|N^{-}(v)|})\} : \forall i \in [|N^{-}(v)|], y_i \leq
       DTr_{N^{-}(v)_i \rightarrow v,j-1} \wedge \sum\limits_{i=1}^{|N^{-}(v)|}y_i = \min(\sum\limits_{i=1}^{|N^{-}(v)|}DTr_{
       N^{-}(v)_i \rightarrow v,j-1}, )$. $\min(\sum\limits_{i=1}^{|N^{-}(v)|}DTr_{N^{-}(v)_i \rightarrow v,j-1}, Loss_{v,j-1})$\\
       \begin{algorithm}[H]
          \label{transitivestealalgo}
          \SetKwInOut{Input}{Input}
          \SetKwInOut{Output}{Output}
          \SetKwFunction{RandomMember}{RandomMember}
          \SetKwFunction{Init}{Init}
          \SetKwFunction{CalculateFlow}{CalculateFlow}
          \Input{$G$ graph, $A$ idle player, $B$ evil player, $U$ capacities, $j_0$ $B$'s turn}
          \Output{$\mathcal{H}$ history}
          \caption{Transitive Steal}
          \Init{} \\
          \While{$Angry \neq \emptyset$}
             {$v \gets$ \RandomMember{$Angry$} \\
              $j \gets j + 1$ \\
              $Turn_j \gets$ \CalculateFlow{$v$,$Loss_v$} \\
%              $w \gets$ \RandomMember{$\{w \in N^{-}(v) : DTr_{w \rightarrow v,j} > 0\}$} \\
              \For{$i \gets 1$ to $|N^{-}(v)|$}
                 {$exchange \gets y_i : Steal(y_i, N^{-}(v)_i) \in Turn_j$ \\
                 $DTr_{N^{-}(v)_i \rightarrow v, j} = DTr_{N^{-}(v)_i \rightarrow v, j-1} - exchange$ \\
                 $Loss_{N^{-}(v)_i} \gets Loss_{N^{-}(v)_i} + exchange$ \\
                 $Loss_v \gets Loss_v - exchange$ \\
                 \If{$N^{-}(v)_i \in Happy$}
                    {$Happy \gets Happy \setminus \{N^{-}(v)_i\}$}
                 \If{$\sum\limits_{w \in N^{-}(N^{-}(v)_i)}DTr_{w \rightarrow N^{-}(v)_i, j} = 0$}
                    {$Sad \gets Sad \cup \{N^{-}(v)_i\}$}
                 \Else{$Angry \gets Angry \cup \{N^{-}(v)_i\}$}}
              \If{$\sum\limits_{v' \in N^{-}(v)}DTr_{v' \rightarrow v, j} = 0$}
                 {$Angry \gets Angry \setminus \{v\}$ \\
                  $Sad \gets Sad \cup \{v\}$}
              \If{$Loss_v = 0$}
                 {$Angry \gets Angry \setminus {v}$ \\
                  $Happy \gets Happy \cup {v}$}}
          \Return $\{Turn_{j_0},...,Turn_j\}$ \\ \ \\
          \Init{} : \\
          $Turn_{j_0} \gets \{Steal(DTr_{N^{-}(B)_1 \rightarrow B, j_0-1}, N^{-}(B)_1), ...,
           Steal(DTr_{N^{-}(B)_{|N^{-}(B)|} \rightarrow B, j_0-1}, N^{-}(B)_{|N^{-}(B)|}),$
          $Add(-DTr_{B \rightarrow N^{+}(B)_1, j_0-1}, N^{+}(B)_1), ...,
           Add(-DTr_{B \rightarrow N^{+}(B)_{|N^{+}(B)|}, j_0-1},N^{+}(B)_{|N^{+}(B)|})\}$ \\
          $Angry \gets N^{-}(B) \setminus \{v \in N^{-}(B) : \sum\limits_{w \in N^{-}(v)}DTr_{w \rightarrow v, j_0} = 0\}$ \\
          $Sad \gets \{v \in N^{-}(B) : \sum\limits_{w \in N^{-}(v)}DTr_{w \rightarrow v, j_0} = 0\}$ \\
          $\forall v \in (Sad \cup Angry), Loss_v \gets DTr_{v \rightarrow B, j_0}$ \\
          $Happy \gets V(G) \setminus (Angry \cup Sad \cup\{A, B\})$ \\
          $\forall v \in Happy, Loss_v \gets 0$ \\
          $Happy \gets \emptyset$ \\
          $j \gets j_0$
       \end{algorithm}
       As we can see from lines 4, 6 and 20-21, $\forall j, \sum\limits_{v \in V(G) \setminus \{A,B\}}Loss_v =
       \sum\limits_{v \in N^{-}(B)}DTr_{v \rightarrow B, j_0}$, that is the total loss is constant and equal to the total
       value stolen by $B$.
       
    \end{proof}

    \begin{theorem}[Trust flow theorem - TOCHECK] \ \\
    \label{trustflow}
       $Tr_{A \rightarrow B} = MaxFlow_{A \rightarrow B}$ (Treating trusts as capacities)
    \end{theorem}
    \begin{proof} \ \\
       Suppose that the flow graph $FG$ is composed of $V(FG)$ nodes and $E(FG)$ edges. Each edge $e_{vw}$ has a
       corresponding capacity $u_{vw}$ which is constant and a corresponding flow $x_{vw}$ which can change depending to the
       flow assignment $X$ we choose. In flow context, for an assignment $X$ to be valid, two properties must hold:
       \begin{enumerate}
          \item $\forall e_{vw} \in E(FG), x_{vw} \leq u_{vw}$
          \item $\forall v \in V(FG), \sum\limits_{v_1 \in N^{+}(v)}x_{v_1v} = \sum\limits_{v_2 \in N^{-}(v)}x_{vv_2}$
       \end{enumerate}
       First we will show that each valid  corresponds 
\ \\ OLD
       \begin{enumerate}
	   \item We will show that $Tr_{A \rightarrow B} \leq MaxFlow_{A \rightarrow B}$.
          We know that $MaxFlow_{A \rightarrow B} = MinCut_{A \rightarrow B}$. We will show that, if everybody except
          A and B follows the conservative strategy,  $Tr_{A \rightarrow B} \leq MinCut_{A \rightarrow B}$. Suppose that in
          round $i$ all the members of the MinCut, $P$, have stolen the maximum value they can from members that belong
          in the MaxFlow graph and nobody in the partition in which $A$ belongs has stolen yet any value. Let the total
          stolen value from the MinCut members be $St$. It is obvious that $St_i \leq MinCut_{A \rightarrow B}$, because
          otherwise there would exist $u \in P$ that doesn't follow the conservative strategy, since they stole more than they
          were stolen from. The same argument holds for any round $i' > i$ because in each round an conservative player can
          steal only up to the value she has been stolen. It is also impossible that the $St$ increase further due to
          stolen value from members of the partition of $B$ since members of $P$ disconnect the two partitions and have
          already played their turns, thus $\forall i' > i, St_{i'} \leq St_i$. There exists a round, $k$, when all the
          conservative players stop stealing, so in the worst case $A$ will have been stolen
          $Tr_{A \rightarrow B} = St_k \leq MinCut_{A \rightarrow B} = MaxFlow_{A \rightarrow B}$.
          \item We can see that $Tr_{A \rightarrow B} \geq MaxFlow_{A \rightarrow B}$ because the strategy where each
          one of the non-idle players steals value equal to the incoming flows from their respective friends is a valid
          strategy that does not contradict with the conservative strategy, since for every conservative player $w$ it holds that
          $\sum\limits_{v \in N^{-}(w)}x_{vw} = \sum\limits_{v \in N^{+}(w)}x_{wv}$ and according to the strategy each
          conservative player will have been stolen value equal to $\sum\limits_{v \in N^{+}(w)}x_{wv}$. More concretely,
          let $Player(j) = B$ and $Player(j+d) = C :$
       \end{enumerate}
       Combining the two results, we see that $Tr_{A \rightarrow B} = MaxFlow_{A \rightarrow B}$.
%        OLD PROOF START
%        \begin{enumerate}
%           \item $Tr_{A \rightarrow B} \geq MaxFlow_{A \rightarrow B}$ because by the definition of $Tr_{A \rightarrow B}$,
%           B leaves taking with him all the incoming trust, so there is no trust flowing towards him after leaving.
%           $Tr_{A \rightarrow B} < MaxFlow_{A \rightarrow B}$ would imply that after B left, there would still remain trust
%           flowing from A to B.
%           \item $Tr_{A \rightarrow B} \leq MaxFlow_{A \rightarrow B}$ \\
%           Suppose that $Tr_{A \rightarrow B} > MaxFlow_{A \rightarrow B}$ (1). Then, using the min cut - max flow theorem we
%           see that there is a set of capacities $U= \{u_1,...,u_n\}$ with flows $X = \{x_1,...,x_n\}$ such that
%           $\sum\limits_{i=1}^{n}{x_i} = MaxFlow_{A \rightarrow B}$ and, if severed $(\forall i \in [n] \: u_i' = 0)$
%           the flow from A to B would be $0$, or, put differently, there would be no directed trust path from A to B. No
%           strategy followed by B could reduce the value of A, so our supposition (1) cannot be true.
%        \end{enumerate}
%        OLD PROOF END
    \end{proof}

    \begin{theorem}[Conservative world theorem] \ \\
    \label{conservativeworld}
       If everybody follows the conservative strategy, nobody steals any amount from anybody.
    \end{theorem}
    \begin{proof} \ \\
       Suppose that there exists a subseries of History, $(Turn_{j_k})$, where $Turn_{j_k} = \{Steal(y_1,B_1),...,
       Steal(y_m,B_m)\}$. This subseries must have an initial element, $Turn_{j_1}$. However, $Player(j_1)$ follows the conservative
       strategy, thus somebody must have stolen from her as well, so $Player(j_1)$ cannot be the initial element. We have a
       contradiction, thus there cannot exist a series of stealing actions when everybody is conservative.
    \end{proof}
    \begin{theorem}[Trust transfer theorem (flow terminology) - TOCHECK] \ \\
    \label{trusttransfer}
       Let $s$ source, $t$ sink, $n = N^{+}(s)$ \\
       $X = \{x_1, ..., x_n\}$ outgoing flows from $s$, \\
       $U = \{u_1, ..., u_n\}$ outgoing capacities from $s$, \\
       $V$ the value to be transferred. \\
       Nodes apart from $s$, $t$ follow the conservative strategy. \\
       Obviously $maxFlow = F = \sum\limits_{i=1}^{n}{x_i}$.
       {\em \begin{lstlisting}
            /                      ....                     \
           / x_s1/u_s1                         x_1t/u_1t     \
          /                                                   \
         /                                                     \
        / x_s2/u_s2                               x_2t/u_2t     \
       s-------------              ....          ------------t
        \      .                                           .    /
         \     .                                           .   /
          \    .                                           .  /
           \ x_sn/u_sn             ....        x_mt/u_mt     /
            \                                               /
       \end{lstlisting}}
       We create a new graph where
       \begin{enumerate}
         \item  $\sum\limits_{i=1}^{n}{u_i'} = F - V$
         \item $\forall i \in [n] \: u_i' \leq x_i$
       \end{enumerate}
 
       It holds that $maxFlow' = F' = F - V$.
    \end{theorem}
    \begin{proof} \
        From theorem \ref{saturation} we can see that $x_i' = u_i'$. It holds that $F' = \sum\limits_{i=1}^nx_i' =
        \sum\limits_{i=1}^nu_i' = F - V$.
    \end{proof}

%    \begin{corollary}[Requirement for $\sum\limits_{i=1}^{n}{u_{s, i}'} = F - V$, $u_{s, i}' \leq x_{s, i}$] \ \\
%       In the setting of \ref{trusttransfer}, it is impossible to have $maxFlow' = F - V$ if
%       $\sum\limits_{i=1}^{n}{u_{s, i}'} > F - V \wedge \forall i \in [n],u_{s, i}' \leq x_{s, i}$.
%    \end{corollary}
%    \begin{proof}
%       Due to \ref{trusttransfer}, $maxFlow' = F - V$ if $\sum\limits_{i=1}^{n}{u_{s, i}'} = F - V
%       \wedge \forall i \in [n], u_{s, i}' \leq x_{s, i}$. If we create new capacities such that
%       $\forall i \in [n], u_{s,i}'' \leq x_{s,i}$, then obviously $maxFlow'' = \sum\limits_{i=1}^{n}{u_{s,i}''}$. If
%       additionally $\sum\limits_{i=1}^{n}{u_{s,i}''} > F - V$, then $maxFlow'' > F - V$.
%    \end{proof}

    \begin{lemma}[Flow limit lemma] \ \\
       \label{flowlimit}
       It is impossible for the outgoing flow $x_i$ from $A$ to an out neighbour of $A$ to be greater than
       $F_{A_i \rightarrow B}$. More formally, $x_i \leq F_{A_i \rightarrow B}$.
    \end{lemma}
    \begin{proof}
       Suppose a configuration where $\exists i : x_i > F_{A_i \rightarrow B}$. If we reduce the capacities $u_k, k \neq i$
       the flow that passes from $i$ in no case has to be reduced. Thus we can set $\forall k \neq i, u_k' = 0$ and $u_i' =
       u_i$. Then $\forall k \neq i,x_k' = 0, x_i' = x_i$ is a valid configuration and thus by definition $F_{A_i \rightarrow
       B} = x_i' = x_i > F_{A_i \rightarrow B}$, which is a contradiction. Thus $\forall i \in [|N^{+}(A)|], x_i \leq
       F_{A_i \rightarrow B}$.
    \end{proof}

    \begin{theorem}[Trust-saving Theorem] \ \\
    \label{trustsave}
       A configuration $U' : u_i' = F_{A_i \rightarrow B}$ for some $i \in [|N^{+}(A)|]$ can yield the same $maxFlow$ with a
       configuration $U'' : u_i'' = u_i, \forall k \in [|N^{+}(A)|], k \neq i, u_k'' = u_k'$.
    \end{theorem}
    \begin{proof}
       We know that $x_i \leq F_{A_i \rightarrow B}$ (lemma \ref{flowlimit}), thus we can see that any increase in $u_i'$
       beyond $F_{A_i \rightarrow B}$ will not influence $x_i$ and subsequently will not incur any change on the rest of the
       flows.
    \end{proof}

    \begin{theorem}[Invariable trust reduction with naive algorithms] \ \\
    \label{invariability}
       Let $A$ source, $n = |N^{+}(A)|$ and $u_i'$ new direct trusts. If $\forall i \in [n],u_i' \leq x_i$,
       Trust Reduction $||\delta_i||_1$ is independent of $x_i, u_i' \:\: \forall$ valid configurations of $x_i$
    \end{theorem}
    \begin{proof} 
       Since $\forall i \in [n],u_i' \leq x_i$ it is (according to \ref{saturation}) $x_i' = u_i'$, thus
       $\delta_i = u_i - x_i'$. We know that $\sum\limits_{i=1}^{n}x_i' = F - V$, so we have $||\delta_i||_1 =
       \sum\limits_{i=1}^{n}\delta_i = \sum\limits_{i=1}^{n}(u_i - x_i') = \sum\limits_{i=1}^{n}u_i - F + V$ independent
       from $x_i', u_i'$
    \end{proof}

    \begin{theorem}[Dependence impossibility theorem] \ \\
    \label{independence}
       ${\partial x_k \over \partial x_i} = 0$ with $x_i$ the flow from MaxFlow $\Rightarrow
         \forall x_i' \leq x_i, {\partial x_k \over \partial x_i} = 0$ ceteris paribus
    \end{theorem}
    \begin{proof}
       TODO
    \end{proof}
    Note: The maxFlow is the same in the following two cases: When a player chooses the evil strategy and when the same
    player chooses a variation of the evil strategy where she does not nullify her outgoing direct trust.
    \begin{theorem}[Trust to multiple players] \ \\
    \label{trustmany}
       Let $S \subset \mathcal{M}, T$ auxiliary player such that $\forall B \in S, DTr_{B \rightarrow T} = \infty$.
       It holds that $\forall A \in \mathcal{M} \setminus S, Tr_{A \rightarrow S} = maxFlow(A, T)$.
    \end{theorem}       
    \begin{proof}
       If $T$ chooses the evil strategy and all players in $S$ play according to the conservative strategy, they will have to steal
       all their incoming direct trust, thus they will act in a way identical to following the evil strategy as far as
       maxFlow is concerned, thus, by \ref{trustflow}, $Tr_{A \rightarrow T} = maxFlow(A, T) = Tr_{A \rightarrow S}$.
%       We will prove theorem \ref{trustmany} by induction.
%       \begin{itemize}
%          \item $|S| = 1, S = \{B\}, DTr_{B \rightarrow T_0} = \infty$. Obviously $maxFlow(A, T_0) = maxFlow(A, B) =
%          Tr_{A \rightarrow B} = Tr_{A \rightarrow S}$, since all the flow that reaches $B$ can also reach $T_0$ due to the
%          unbounded direct trust from $B$ to $T_0$.
%          \item Suppose that for any $S \subset \mathcal{M}, \forall B \in S, DTr_{B \rightarrow T} = \infty$ it holds that
%          $maxFlow(A, T) = Tr_{A \rightarrow S}$.
%          \item We will show that for $S' = S \cup \{C\}, \forall B \in S, DTr_{B \rightarrow T} = \infty,
%          DTr_{T \rightarrow T'} = \infty, DTr_{C \rightarrow T'} = \infty$ it holds that $maxFlow(A, T') =
%          Tr_{A \rightarrow S'}$. \\
%          From the inductive ypothesis we know that $Tr_{A \rightarrow S} = maxFlow(A, T)$. If $T'$ chooses the evil strategy,
%          $T$ and $C$ will have to steal all their incoming direct trust, thus they will act  
%       \end{itemize}
    \end{proof}

    One of the primary aims of this system is to mitigate the danger for sybil attacks whilst maintaining fully decentralized
    autonomy. Let Eve be a possible attacker. Since participation in the network does not require any kind of registration,
    Eve can create any number of players. We will call the set of these players $\mathcal{C}$. Moreover, Eve can invest any
    amount she chooses, thus she can arbitrarily set the direct trusts of any player $C \in \mathcal{C}$ to any player $P \in
    \mathcal{M}$ ($DTr_{C \rightarrow P}$) and can also steal all incoming direct trust to these players. Additionally, we
    give Eve a set of players $B \in \mathcal{B}$ that she has corrupted, so she fully controls their direct trusts to any
    player $P \in \mathcal{M}$ ($DTr_{B \rightarrow P}$) and can also steal all incoming direct trust to these players. The
    players $B \in \mathcal{B}$ are considered to be legitimate before the corruption, thus they can be directly trusted by
    any player $P \in \mathcal{M}$ ($DTr_{P \rightarrow B} \geq 0$). However, players $C \in \mathcal{C}$ can be trusted only
    by players $D \in \mathcal{B} \cup \mathcal{C}$ ($DTr_{D \rightarrow C} \geq 0$) and not by players $A \in \mathcal{M}
    \setminus (\mathcal{B} \cup \mathcal{C})$ ($DTr_{A \rightarrow C} = 0$).
    \begin{theorem}[Sybil resistance] \ \\
    \label{sybil}
       Let $\mathcal{B} \cup \mathcal{C} \subset \mathcal{M} (\mathcal{B} \cap \mathcal{C} = \emptyset)$ be a collusion of
       players who are controlled by an adversary, Eve. Eve also controls the number of players in $\mathcal{C},
       |\mathcal{C}|$, but players $C \in \mathcal{C}$ are not directly trusted by players outside the collusion, contrary
       to players $B \in \mathcal{B}$ who may be directly trusted by any player in $\mathcal{M}$. It holds that
       $Tr_{A \rightarrow \mathcal{B}} = Tr_{A \rightarrow \mathcal{B} \cup \mathcal{C}}$.
    \end{theorem}
    \begin{proof}
       Suppose that there exist $|\mathcal{B} \cup \mathcal{C}|$ consecutive turns during which all the colluding players
       choose actions according to the evil strategy. More formally, suppose that $\exists j: \forall d \in [|\mathcal{B}
       \cup \mathcal{C}|], Player(j+d) \in \mathcal{B} \cup \mathcal{C} \wedge \forall d_1, d_2 \in [|\mathcal{B} \cup
       \mathcal{C}|], d_1 \neq d_2, Player(j + d_1) \neq Player(j + d_2) \wedge \forall d \in [|\mathcal{B} \cup
       \mathcal{C}|], Strategy(Player(j+d)) = Evil$. Let $T$ be an auxiliary player such that $\forall B \in \mathcal{B},
       DTr_{B \rightarrow T} = \infty$ and $T'$ be another auxiliary player such that $\forall D \in \mathcal{B} \cup
       \mathcal{C}, DTr_{D \rightarrow T'} = \infty$. According to \ref{trustmany}, $Tr_{A \rightarrow \mathcal{B}} =
       maxFlow(A, T), Tr_{A \rightarrow \mathcal{B} \cup \mathcal{C}} = maxFlow(A, T')$. Consider the partition of
       $\mathcal{M}, \mathcal{P} = \{\mathcal{B} \cup \mathcal{C}, \mathcal{M} \setminus (\mathcal{B} \cup \mathcal{C})\} =
       \{P_1, P_2\}$. The edges from $P_2$ to $P_1$ will carry a flow $X_P, X_{P'}$ and the edges inside of $P_1$ will carry
       a flow $X_T, X_{T'}$ from the calculation of $maxFlow(A, T), maxFlow(A, T')$ respectively. $maxFlow(A, T) \leq
       maxFlow(A, T')$ because the maximal configuration of $X_T$ can be part of a valid configuration of $X_{T'}$ since
       edges in $\mathcal{B}$ are edges in $\mathcal{B} \cup \mathcal{C}$. If both maxFlows are not infinite, then their
       MinCut is either entirely in $P_2$ or in $P_2$ and the edges from $P_2$ to $P_1$, because otherwise $minCut = \infty$
       since it contains saturated infinite edges. However, then in both cases the minCut is the same, thus $maxFlow(A, T) =
       maxFlow(A, T')$. Finally, we will show that if $maxFlow(A, T') = \infty$, then $maxFlow(A, T) = \infty$. If
       $maxFlow(A, T') = \infty$, then there is infinite flow entering $P_1$ and, because all endpoints of flows entering
       $P_1$ are in $\mathcal{B}$, the same infinite flow can be assigned in the case of $maxFlow(A, T)$, thus
       $maxFlow(A, T) = \infty$. Thus we conclude that $Tr_{A \rightarrow \mathcal{B}} =
       Tr_{A \rightarrow \mathcal{B} \cup \mathcal{C}}$.
       
       
    \end{proof}
    We have proven that controlling $|\mathcal{C}|$ is irrelevant for Eve, thus Sybil attacks are meaningless. \\

    Here we show three naive algorithms for calculating new direct trusts so as to maintain invariable risk when paying
    a trusted party. To prove the correctness of the algorithms, it suffices to prove that $\forall i \in [n] \:
    u_i' \leq x_i$ and that $\sum\limits_{i=1}^{n}u_i' = F - V$ where $F = \sum\limits_{i=1}^{n}x_i$. \\
    \begin{algorithm}[H]
       \label{fcfs}
       \SetKwInOut{Input}{Input}
       \SetKwInOut{Output}{Output}
       \Input{$x_i$ flows, $n = |N^{+}(s)|$, $V$ value}
       \Output{$u_i'$ capacities}
       \caption{First-come, first-served trust transfer}
       $F \gets \sum\limits_{i=1}^{n}x_i$ \\
       \If{$F < V$}{\Return $\bot$}
       $F_{cur} \gets F$ \\
       \For{$i \gets 1$ to $n$}
          {$u_i' \gets x_i$} 
       $i \gets 1$ \\
       \While{$F_{cur} > F - V$}
          {$reduce \gets \min{(x_i, F_{cur} - F + V)}$ \\
           $F_{cur} \gets F_{cur} - reduce$ \\
           $u_i' \gets x_i - reduce$ \\
           $i \gets i + 1$}
       \Return $U' = \bigcup\limits_{k=1}^{n}\{u_k'\}$
    \end{algorithm}
    \begin{proof}[Proof of correctness for algorithm \ref{fcfs}] \
       \begin{itemize}
          \item We will show that $\forall i \in [n] \: u_i' \leq x_i$. \\
          Let $i \in [n]$. In line 6 we can see that $u_i' = x_i$ and the only other occurence of $u_i'$
          is in line 11 where it is never increased $(reduce \geq 0)$, thus we see that, when returned, $u_i' \leq x_i$.
          \item We will show that $\sum\limits_{i=1}^{n}u_i' = F - V$. \\
          $F_{cur,0} = F$ \\
          If $F_{cur,i} \geq F - V$, then $F_{cur,i+1}$ does not exist because the \emph{while} loop breaks after calculating
          $F_{cur,i}$. \\
          Else $F_{cur,i+1} = F_{cur,i} - \min{(x_{i+1}, F_{cur,i} - F + V)}$. \\
          If for some $i, \min{(x_{i+1}, F_{cur,i} - F + V)} = F_{cur,i} - F + V$, then $F_{cur,i+1} = F - V$, so if
          $F_{cur,i+1}$ exists, then $\forall k < i, F_{cur,k} = F_{cur,k-1} - x_k \Rightarrow F_{cur,i} =
          F - \sum\limits_{k=1}^{i}x_k$ \\
          Furthermore, if $F_{cur,i+1} = F - V$ then $u_{i+1}' = x_{i+1} - F_{cur,i} + F - V =
          x_i - F + \sum\limits_{k=1}^{i-1}x_k + F - V = \sum\limits_{k=1}^{i}x_k - V$, $\forall k \leq i, u_k' = 0$
          and $\forall k > i+1, u_k' = x_k$. \\
          In total, we have $\sum\limits_{k=1}^{n}u_k' = \sum\limits_{k=1}^{i}x_k - V + \sum\limits_{k=i+1}^{n}x_k =
          \sum\limits_{k=1}^{n}x_k - V \Rightarrow \sum\limits_{k=1}^{n}u_k' = F - V$.
       \end{itemize}
    \end{proof}
    \begin{proof}[Complexity of algorithm \ref{fcfs}] \ \\
       First we will prove that on line 13 $i \leq n+1$. Suppose that $i > n+1$ on line 13. This means that $F_{cur,n}$
       exists and $F_{cur,n} = F - \sum\limits_{i=1}^{n}x_i = 0 \leq F - V$ since, according to the condition on line 2,
       $F - V \geq 0$. This means however that the \emph{while} loop on line 8 will break, thus $F_{cur,n+1}$ cannot exist
       and $i = n + 1$ on line 13, which is a contradiction, thus $i \leq n+1$ on line 13. Since $i$ is incremented by 1
       on every iteration of the \emph{while} loop (line 12), the complexity of the \emph{while} loop is $O(n)$ in the
       worst case. The complexity of lines 2-4 and 7 is $O(1)$ and the complexity of lines 1, 5-6 and 13 is $O(n)$, thus
       the total complexity of algorithm \ref{fcfs} is $O(n)$.
    \end{proof}

    \begin{algorithm}[H]
       \label{abs}
       \SetKwInOut{Input}{Input}
       \SetKwInOut{Output}{Output}
       \Input{$x_i$ flows, $n = |N^{+}(s)|$, $V$ value}
       \Output{$u_i'$ capacities}
       \caption{Absolute equality trust transfer ($||\Delta_i||_\infty$ minimizer)}
       $F \gets \sum\limits_{i=1}^{n}x_i$ \\
       \If{$F < V$}{\Return $\bot$}
       \For{$i \gets 1$ to $n$}
          {$u_i' \gets x_i$}
       $reduce \gets {V \over n}$ \\
       $reduction \gets 0$ \\
       $empty \gets 0$ \\
       $i \gets 0$ \\
       \While{$reduction < V$}
          {\If{$u_i' > 0$}{\If{$x_i < reduce$}
                {$empty \gets empty + 1$ \\
                 \If{$empty < n$}
                    {$reduce \gets reduce + \frac{reduce - x_i}{n - empty}$}
                 $reduction \gets reduction + u_i'$ \\
                 $u_i' \gets 0$ \\}
           \ElseIf{$x_i \geq reduce$}{$reduction \gets reduction + u_i' - (x_i - reduce)$ \\
                 $u_i' \gets x_i - reduce$}}
           $i \gets (i + 1) mod \:n$}
       \Return $U' = \bigcup\limits_{k=1}^{n}\{u_k'\}$
    \end{algorithm}
       \noindent
       We will start by showing some results useful for the following proofs. Let $j$ be the number of iterations of the
       \textbf{while} loop for the rest of the proofs for algorithm \ref{abs} (think of $i$ from line 20 without the
       $mod\:n$).\\
       First we will show that $empty \leq n$. $empty$ is only modified on line 12 where it is incremented by 1. This
       happens only when $u_i' > 0$ (line 11), which is assigned the value 0 on line 16. We can see that the
       incrementation of $empty$ can happen at most $n$ times because $|U'| = n$. Since $empty_0 = 0$, $empty \leq n$
       at all times of the execution. \\
       Next we will derive the recursive formulas for the various variables. \\
       $empty_0 = 0$ \\
       $empty_{j+1} = 
          \begin{cases}
             empty_j, & u_{(j+1)\:mod\:n}' = 0 \\
             empty_j+1, & u_{(j+1)\:mod\:n}' > 0 \: \wedge \: x_{(j+1) \:mod\:n} < reduce_j \\
             empty_j, & u_{(j+1)\:mod\:n}' > 0 \: \wedge \: x_{(j+1) \:mod\:n} \geq reduce_j
          \end{cases}$ \\ \ \\
       $reduce_0 = \frac{V}{n}$ \\
       $reduce_{j+1} =
          \begin{cases}
             reduce_j, & u_{(j+1)\:mod\:n}' = 0 \\
             reduce_j + \frac{reduce_j-x_{(j+1)\:mod\:n}}{n-empty_{j+1}}, & u_{(j+1)\:mod\:n}' > 0 \: \wedge \:
                x_{(j+1) \:mod\:n} < reduce_j \\
             reduce_j, & u_{(j+1)\:mod\:n}' > 0 \: \wedge \: x_{(j+1) \:mod\:n} \geq reduce_j
          \end{cases}$ \\ \ \\
       $reduction_0 = 0$ \\
       $reduction_{j+1} =
          \begin{cases}
             reduction_j, & u_{(j+1)\:mod\:n}' = 0 \\
             reduction_j + u_{(j+1)\:mod\:n}', & u_{(j+1)\:mod\:n}' > 0 \: \wedge \: x_{(j+1) \:mod\:n} < reduce_j \\
             reduction_j + u_{(j+1)\:mod\:n}' - x_{(j+1)\:mod\:n} + reduce_{j+1}, &
                u_{(j+1)\:mod\:n}' > 0 \: \wedge \: x_{(j+1) \:mod\:n} \geq reduce_j
          \end{cases}$ \\
       In the end, $r = reduce$ is such that $r = \frac{V - \sum\limits_{x \in S}x}{n - |S|}$ where
       $S = \{\text{flows } y \text{ from } s \text{ to } N^{+}(s) \text{ according to } maxFlow : y < r\}$. Also,
       $\sum\limits_{i=1}^{n}u_i' = \sum\limits_{i=1}^{n}\max{(0,x_i - r)}$. TOPROVE
    \begin{proof}[Proof of correctness for algorithm \ref{abs}] \
       \begin{itemize}
          \item We will show that $\forall i \in [n] \: u_i' \leq x_i$. \\
          On line 9, $\forall i \in [n] \: u_i' = x_i$. Subsequently $u_i'$ is modified on line 16, where
          it becomes equal to 0 and on line 19, where it is assigned $x_i - reduce$. It holds that $x_i - reduce \leq x_i$
          because initially $reduce = \frac{V}{n} \geq 0$ and subsequently $reduce$ is modified only on line 14 where it
          is increased ($n > empty$ because of line 13 and $reduce > x_i$ because of line 11, thus
          $\frac{reduce - x_i}{n - empty} > 0$). We see that $\forall i \in [n], u_i' \leq x_i$.
          \item We will show that $\sum\limits_{i=1}^{n}u_i' = F - V$. \\
          The variable $reduction$ keeps track of the total reduction that has happened and breaks the \textbf{while} loop
          when $reduction \geq V$. We will first show that $reduction = \sum\limits_{i=1}^{n}(x_i- u_i')$ at all times and
          then we will prove that $reduction = V$ at the end of the execution. Thus we will have proven that
          $\sum\limits_{i=1}^{n}u_i'= \sum\limits_{i=1}^{n}x_i - V = F - V$.
          \begin{itemize}
             \item On line 9, $u_i' = x_i \Rightarrow \sum\limits_{i=1}^{n}(x_i- u_i') = 0$ and $reduction = 0$. \\
             On line 16, $u_i'$ is reduced to 0 thus $\sum\limits_{i=1}^{n}(x_i- u_i')$ is increased by $u_i'$.
             Similarly, on line 15 $reduction$ is increased by $u_i'$, the same as the increase in
             $\sum\limits_{i=1}^{n}(x_i- u_i')$. \\
             On line 19, $u_i'$ is reduced by $u_i' - x_i + reduce$ thus $\sum\limits_{i=1}^{n}(x_i- u_i')$ is increased
             by $u_i' - x_i + reduce$. On line 18, $reduction$ is increased by $u_i' - x_i + reduce$, which is equal
             to the increase in $\sum\limits_{i=1}^{n}(x_i- u_i')$. \\
             We also have to note that neither $u_i'$ nor $reduction$ is modified in any other way from line 10 and on,
             thus we conclude that $reduction = \sum\limits_{i=1}^{n}(x_i- u_i')$ at all times.
             \item Suppose that $reduction_j > V$ on the line 21. Since $reduction_j$ exists, $reduction_{j-1} < V$.
             If $x_{j \: mod \: n} < reduce_{j-1}$ then $reduction_j = reduction_{j-1} + u_{j \: mod \:n}'$.
             Since $reduction_j > V$, $u_{j \: mod \:n}' > V - reduction_{j-1}$. TOCOMPLETE\\
             
          \end{itemize}
       \end{itemize}
    \end{proof}
    \begin{proof}[Complexity of algorithm \ref{abs}] \ \\
       In the worst case scenario, each time we iterate over all capacities only the last non-zero capacity will become zero
       and every non-zero capacity must be recalculated. This means that every $n$ steps exactly 1 capacity becomes zero
       and eventually all capacities (maybe except for one) become zero. Thus we need $O(n^2)$ steps in the worst case.
    \end{proof}
    A variation of this algorithm using a Fibonacci heap with complexity $O(n)$ can be created, but that is part of 
    further research.
    \begin{proof}[Proof that algorithm \ref{abs} minimizes the $||\Delta_i||_\infty$ norm] \ \\
       Suppose that $U'$ is the result of an execution of algorithm \ref{abs} that does not minimize the $||\Delta_i||_\infty$
       norm. Suppose that $W$ is a valid solution that minimizes the $||\Delta_i||_\infty$ norm. Let $\delta$ be the minimum
       value of this norm. There exists $i \in [n]$ such that $x_i - w_i = \delta$ and $u_i' < w_i$. Because both $U'$
       and $W$ are valid solutions ($\sum\limits_{i=1}^{n}u_i' = \sum\limits_{i=1}^{n}w_i = F - V$), there must exist a set
       $S \subset U'$ such that $\forall u_j' \in S, u_j' > w_j$ TOCOMPLETE.
    \end{proof}
    \begin{algorithm}[H]
       \label{prop}
       \SetKwInOut{Input}{Input}
       \SetKwInOut{Output}{Output}
       \Input{$x_i$ flows, $n = |N^{+}(s)|$, $V$ value}
       \Output{$u_i'$ capacities}
       \caption{Proportional equality trust transfer}
       $F \gets \sum\limits_{i=1}^{n}x_i$ \\
       \If{$F < V$}{\Return $\bot$}
       \For{$i \gets 1$ to $n$}
          {$u_i' \gets x_i - \frac{V}{F} x_i$}
       \Return $U' = \bigcup\limits_{k=1}^{n}\{u_k'\}$
    \end{algorithm} \ \\
    \begin{proof}[Proof of correctness for algorithm \ref{prop}] \
       \begin{itemize}
          \item We will show that $\forall i \in [n] \: u_i' \leq x_i$. \\
          According to line 5, which is the only line where $u_i'$ is changed, $u_i' = x_i - \frac{V}{F}x_i \leq x_i$
          since $x_i, V, F > 0$ and $V \leq F$.
          \item We will show that $\sum\limits_{i=1}^{n}u_i' = F - V$. \\
          With $F = \sum\limits_{i=1}^{n}x_i$, on line 6 it holds that $\sum\limits_{i=1}^{n}u_i' = \sum\limits_{i=1}^{n}
          (x_i - \frac{V}{F}x_i) = \sum\limits_{i=1}^{n}x_i - \frac{V}{F}\sum\limits_{i=1}^{n}x_i = F - V$.
       \end{itemize}
    \end{proof}
    \begin{proof}[Complexity of algorithm \ref{prop}] \ \\
       The complexity of lines 1, 4-5 and 6 is $O(n)$ and the complexity of lines 2-3 is $O(1)$, thus the total complexity
       of algorithm \ref{prop} is $O(n)$.
    \end{proof}
    Naive algorithms result in $u_i' \leq x_i$, thus according to \ref{invariability}, $||\delta_i||_1$ is invariable for
    any of the possible solutions $U'$, which is not necessarily the minimum (usually it will be the maximum). The following
    algorithms concentrate on minimizing two $\delta_i$ norms, $||\delta_i||_\infty$ and $||\delta_i||_1$. \\
    \begin{algorithm}[H]
       \label{dinf}
       \SetKwInOut{Input}{Input}
       \SetKwInOut{Output}{Output}
       \SetKwFunction{BinSearch}{BinSearch}
       \Input{$X = \{x_i\}$ flows, $n = |N^{+}(s)|$, $V$ value, $\epsilon_1$, $\epsilon_2$}
       \Output{$u_i'$ capacities}
       \caption{$||\delta_i||_\infty$ minimizer}
       \If{$\epsilon_1 < 0 \vee \epsilon_2 < 0$}
          {\Return $\bot$}
       $F \gets \sum\limits_{i=1}^{n}x_i$ \\
       \If{$F < V$}
          {\Return $\bot$}
       $\delta_{max} \gets \max\limits_{i \in [n]}\{u_i\}$ \\
       $\delta^* \gets$ \BinSearch{0,$\delta_{max}$,F-V,n,X,$\epsilon_1$,$\epsilon_2$} \\
       \For{$i \gets 1$ to $n$}
          {$u_i' \gets \max{(u_i - \delta^*, 0)}$}
       \Return $U' = \bigcup\limits_{k=1}^{n}\{u_k'\}$
    \end{algorithm}
    Since trust should be considered as a continuous unit and binary search dissects the possible interval for the solution
    on each recursive call, inclusion of the $\epsilon$-parameters in \texttt{BinSearch} is necessary for the algorithm to
    complete in a finite number of steps. \\
    \begin{algorithm}[H]
       \label{binsearch}
       \SetKwFunction{BinSearch}{BinSearch}
       \SetKwInOut{Input}{Input}
       \SetKwInOut{Output}{Output}
       \Input{$bot$, $top$, $F'$, $n$, $X$, $\epsilon_1$, $\epsilon_2$}
       \Output{$\delta^*$}
       \caption*{\textbf{function} \texttt{BinSearch} }
       \If{$bot = top$}{\Return $bot$}
       \Else{
          \For{$i \gets 1$ to $n$}
              {$u_i' \gets \max{(0,u_i - \frac{top + bot}{2})}$}
          \If{$maxFlow < F' - \epsilon_1$}
	     {\Return \BinSearch{$bot$, $\frac{top+bot}{2}$,$F'$,$n$,$X$,$\epsilon_1$,$\epsilon_2$}}
          \ElseIf{$maxFlow > F' + \epsilon_2$}
	     {\Return \BinSearch{$\frac{top+bot}{2}$, $top$,$F'$,$n$,$X$.$\epsilon_1$,$\epsilon_2$}}
          \Else
             {\Return $\frac{top + bot}{2}$}
       }
    \end{algorithm}
    \begin{proof}[Proof that $maxFlow(\delta)$ is strictly decreasing for $\delta: maxflow(\delta) < F$] \ \\
       Let $maxFlow(\delta)$ be the $maxFlow$ with $\forall i \in [n], u_i' = max(0, u_i - \delta)$.
       We will prove that the function $maxFlow(\delta)$ is strictly decreasing for all $\delta \leq \max\limits_{i \in
       [n]}\{u_i\}$ such that $maxFlow(\delta) < F$. \\
       Supppose that $\exists \delta_1, \delta_2 : \delta_1 < \delta_2 \wedge maxFlow(\delta_1) \leq maxFlow(\delta_2) < F$.
       We will work with configurations of $x_{i,j}'$ such that $x_{i,j}' \leq x_i, j \in \{1,2\}$. \\
       Let $S_j = \{i \in N^{+}(s) : i \in MinCut_j\}$. It holds that $S_1 \neq \emptyset$ because otherwise $MinCut_1 =
       MinCut_{\delta = 0}$ which is a contradiction because then $maxFlow(\delta_1) = F$. Moreover, it holds that
       $S_1 \subseteq S_2$, since $\forall u_{i,2}' > 0,u_{i,2}' < u_{i,1}'$. Every node in the $MinCut_j$ is saturated, thus
       $\forall i \in S_1, x_{i,j}' = u_{i,j}'$. Thus $\sum\limits_{i \in S_1} x_{i,2} < \sum\limits_{i \in S_1}x_{i,1}$ and,
       since $maxFlow(\delta_1) \leq maxFlow(\delta_2)$, we conclude that for the same configurations,
       $\sum\limits_{i \in N^{+}(s) \setminus S_1} x_{i,2} > \sum\limits_{i \in N^{+}(s) \setminus S_1}x_{i,1}$.
       However, since $x_{i,j}' \leq x_i, j \in \{1,2\}$, the configuration
       $[x_{i,1}'' = x_{i,2}', i \in N^{+}(s) \setminus S_1], [x_{i,1}'' = x_{i,1}', i \in S_1]$ is valid for
       $\delta = \delta_1$ and then $\sum\limits_{i \in S_1}x_{i,1}'' + \sum\limits_{i \in N^{+}(s) \setminus S_1}x_{i,1}'' =
       \sum\limits_{i \in S_1}x_{i,1}' + \sum\limits_{i \in N^{+}(s) \setminus S_1}x_{i,2}' > maxFlow(\delta_1)$,
       contradiction. Thus $maxFlow(\delta)$ is strictly decreasing.
    \end{proof}
       We can see that if $V > 0, F' = F - V < F$ thus if $\delta \in (0, \max\limits_{i \in [n]}\{u_i\}]:
       maxFlow(\delta)= F' \Rightarrow \delta = \min||\delta_i||_\infty : maxFlow(||\delta_i||_\infty) = F'$.
       
    \begin{proof}[Proof of correctness for function \ref{binsearch}] \ \\
       Supposing that $[F' - \epsilon_1, F' + \epsilon_2] \subset [maxFlow(top),maxFlow(bot)]$, or equivalently
       $maxFlow(top) \leq F' - \epsilon_1 \wedge maxFlow(bot) \geq F' + \epsilon_2$, we will prove that
       $maxFlow(\delta^*) \in [F' - \epsilon_1, F' + \epsilon_2]$. \\
       First of all, we should note that if an invocation of \texttt{BinSearch} returns without calling
       \texttt{BinSearch} again (line 2 or 11), its return value will be equal to the return value of the initial invocation
       of \texttt{BinSearch}, as we can see on lines 7 and 9, where the return value of the invoked \texttt{BinSearch}
       is returned without any modification. The case where \texttt{BinSearch} is called again is analyzed next:
       \begin{itemize}
          \item If $maxFlow(\frac{top+bot}{2}) < F' - \epsilon_1 < F'$ (line 6) then, since $maxFlow(\delta)$ is strictly
          decreasing, $\delta^* \in [bot,\frac{top+bot}{2})$. As we see on line 7, the interval $(\frac{top+bot}{2}, top]$
          is discarded when the next \texttt{BinSearch} is called. Since $F' + \epsilon_2 \leq maxFlow(bot)$, we have
          $[F' - \epsilon_1, F' + \epsilon_2] \subset [maxFlow(\frac{top+bot}{2}), maxFlow(bot)]$ and
          the length of the available interval is divided by 2.
          \item Similarly, if $maxFlow(\frac{top+bot}{2}) > F' + \epsilon_2 > F'$ (line 8) then $\delta^* \in
          (\frac{top+bot}{2}, top]$. According to line 9, the interval $[bot, \frac{top+bot}{2})$ is discarded when the next
          \texttt{BinSearch} is called. Since $F'- \epsilon_1 \geq maxFlow(top)$, we have $[F' - \epsilon_1, F' + \epsilon_2]
          \subset (maxFlow(top),$ $maxFlow(\frac{top+bot}{2})]$ and the length of the available interval is divided by 2.
       \end{itemize}
       As we saw, $[F' - \epsilon_1, F' + \epsilon_2] \subset [maxFlow(top),maxFlow(bot)]$ in every recursive call and
       $top - bot$ is divided by 2 in every call. From topology we know that $A \subset B \Rightarrow |A| < |B|$, so the
       recursive calls cannot continue infinitely. $|[F' - \epsilon_1, F' + \epsilon_2]| = \epsilon_1 + \epsilon_2$. Let
       $bot_0, top_0$ the input values given to the initial invocation of \texttt{BinSearch}, $bot_j,top_j$ the input
       values given to the $j$-th recursive call of \texttt{BinSearch} and $len_j =|[bot_j, top_j]| = top_j - bot_j$. We have
       $\forall j > 0, len_j = top_j - bot_j = \frac{top_{j-1} - bot_{j-1}}{2} \Rightarrow \forall j >0, len_j =
       \frac{top_0 - bot_0}{2^j}$. We understand that in the worst case $len_j = \epsilon_1 + \epsilon_2 \Rightarrow
       2^j = \frac{top_0-bot_0}{\epsilon_1 + \epsilon_2} \Rightarrow j = \log_2(\frac{top_0-bot_0}{\epsilon_1+\epsilon_2})$.
       Also, as we saw earlier, $\delta^*$ is always in the available interval, thus $maxFlow(\delta^*) \in [F' - \epsilon_1,
       F' + \epsilon_2]$.
%       We will show that the output of \ref{binsearch}, $\delta \in [bot_0, top_0]$, is such that
%\subset [0, \max\limits_{i \in [n]}\{u_i\}]
%       $\sum\limits_{i=1}^{n}\max{(u_i - \delta, 0)} = F' = F - V$. \\
%       We can easily see that $\delta_1 < \delta_2 \Rightarrow \sum\limits_{i=1}^{n}\max{(u_i - \delta_1, 0)} >
%       \sum\limits_{i=1}^{n}\max{(u_i - \delta_2, 0)} \Rightarrow maxFlow_{\delta_1} \geq maxFlow_{\delta_2} (1)$.
%       The recursive function starts backtracking either on line 11, where $maxFlow = F'$, or on line 2 where $bot_j=top_j$.
%       In the latter case, it is $round(\frac{bot_{j-1}+top_{j-1}}{2}) = bot_j$ and we have either $bot_{j-1} = bot_j$ or
%       $top_{j-1} = top_j$.
%       \begin{itemize}
%          \item $bot_{j-1} = bot_j \Rightarrow round(\frac{bot_j + top_{j-1}}{2}) = bot_j \xRightarrow{top_{j-1} > bot_j}
%          bot_j < \frac{bot_j + top_{j-1}}{2} < bot_j + 0.5 \Rightarrow bot_j < top_{j-1} < bot_j + 1$ impossible.
%          \item $top_{j-1} = top_j \Rightarrow round(\frac{bot_{j-1} + top_j}{2}) = top_j \xRightarrow{top_j > bot_{j-1}}
%          top_j - 0.5 \leq \frac{bot_{j-1} + top_j}{2} < top_j \Rightarrow top_j - 1 \leq bot_{j-1} < top_j
%          \Rightarrow bot_{j-1} = top_j - 1$. In this case $round(\frac{bot_{j-1} + top_{j-1}}{2}) =
%          round(\frac{top_j - 1 + top_j}{2}) = round(top_j - 0.5) = top_j \Rightarrow
%          maxFlow_{\frac{bot_{j-1} + top_{j-1}}{2}} = maxFlow_{bot_j}$. Since $bot_j$ exists, \\
%          $maxFlow_{\frac{bot_{j-1} + top_{j-1}}{2}} \neq F'$.
%       \end{itemize}
%$bot_{j-1} = bot_j - 1 \wedge top_{j-1} = top_j$ or $bot_{j-1} = bot_j \wedge
%       top_{j-1} = top_j + 1$.
%       \begin{itemize}
%          \item If $bot_{j-1} = bot_j - 1 \wedge top_{j-1} = top_j, maxFlow_{\frac{top_{j-1}+bot_{j-1}}{2}} >F',
%          (1) \Rightarrow maxFlow_{bot_j} \leq maxFlow_{\frac{top_{j-1}+bot_{j-1}}{2}}$
%       \end{itemize}
%$\forall \delta': 0 \leq \delta' < bot_j, maxFlow > F'$ because $\exists i \in [0,j):bot_i \leq \delta' \leq top_i$
    \end{proof}
    \begin{proof}[Complexity of function \ref{binsearch}] \ \\
       Lines 1-2 have complexity $O(1)$, lines 4-5 have complexity $O(n)$, lines 6-11 have complexity
       $O(maxFlow) + O(BinSearch)$. As we saw in the proof of correctness for function \ref{binsearch}, we need at most
       $\log_2(\frac{top - bot}{\epsilon_1 + \epsilon_2})$ recursive calls of \texttt{BinSearch}. Thus the function
       \ref{binsearch} has worst-case complexity $O((maxFlow + n)\log_2(\frac{top - bot}{\epsilon_1 + \epsilon_2}))$.
    \end{proof}
    \begin{proof}[Proof of correctness for algorithm \ref{dinf}] \ \\
       We will show that $maxFlow \in [F - V - \epsilon_1, F - V + \epsilon_2]$, with $u_i'$ decided by algorithm
       \ref{dinf}. \\
       Obviously $maxFlow(0) = F, maxFlow(\max\limits_{i \in [n]}\{u_i\}) = 0$, thus $\delta^* \in
       \max\limits_{i \in [n]}\{u_i\}$. According to the proof of correctness for function \ref{binsearch},
       we can directly see that $maxFlow(\delta^*) \in [F - V - \epsilon_1, F - V + \epsilon_2]$, given that
       $\epsilon_1, \epsilon_2$ are chosen so that $F - V - \epsilon_1 \geq 0, F - V + \epsilon_2 \leq F$, so as to satisfy
       the condition $[F' - \epsilon_1, F' + \epsilon_2] \subset [maxFlow(top),maxFlow(bot)]$.
    \end{proof}
    \begin{proof}[Complexity of algorithm \ref{dinf}] \ \\
       The complexity of lines 1,2 and 4-6 is $O(n)$ and the complexity of line 3 is $O(BinSearch) = O((maxFlow + n)
       \log_2(\frac{\delta_{max}}{\epsilon_1 + \epsilon_2}))$, thus the total complexity of algorithm \ref{dinf} is
       $O((maxFlow + n)\log_2(\frac{\delta_{max}}{\epsilon_1 + \epsilon_2}))$.
    \end{proof}    
    However, we need to minimize $\sum\limits_{i=1}^{n}(u_i-u_i') = ||\delta_i||_1$.

  \section{Further Research}

  \section{References}

\end{document}
